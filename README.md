# XSS攻击模拟
1.需要express模版搭建服务器<br>
2.因为node_modules太大，因此项目中没有拷贝，需要下载此项目的同学需要npm install命令安装package.json的依赖<br>
3.两个引用的第三方的库名字不一样，分别是he.js  与htmlparse.js  但是功能和对外暴露的接口是一致的，不需要担心<br>
4.以下是笔记部分<br>
<br>
# XSS 攻击（跨站脚本）笔记
一、理解XSS的攻击方式<br>
（1）存储型XSS：存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie<br>
（2）反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。<br>

二、XSS防御措施<br>
1.编码：对用户输入的数据进行HTML Entity编码，如">", "<"," ","&","\n"等<br>
2.过滤：<br>
    ⑴移除用户上传的DOM属性，如onerro,onclick，onchange，onclick等；<br>
    ⑵移除用户上传输入的style,script,frame,iframe,link标签;<br>
3.校正：<br>
    ⑴避免直接对HTML Entity解码<br>
    ⑵使用DomParse转换，校正不配对的DOM标签<br>
1. nodejs后台可安装xss.js这个包模块来解决。对传入数据库的提交输出都经过这个模块过滤即可
       
# CSRF 攻击(跨站请求伪造)笔记

一、CSRF攻击方式<br>
  用户在a站前端页面发起登录（身份认证）请求
  a站后端确认身份，登录成功，cookie中存在用户的身份认证信息
  用户未退出网站a之前，在同一浏览器中，打开一个TAB页访问网站b（B可以是一张src里面是接口地址的图片）；
  b站前端页面向a站后端发起请求，带着a站的cookie信息（身份认证信息），请求成功
  只要用户访问了b站的前端页面，b站就可以在用户完全不知道的情况下，带着a站的用户登录态（cookie）向a站发起请求

二、CSRF防御方式<br>
  CSRF的发生有几个特点：<br>
  b站发送的请求带着a站的cookie信息；<br>
  b站发送请求不经过a站的前端<br>
  http请求头中的referer为b站<br>
  我们可以从这些特点入手，思考防御的办法：<br>
  禁止第三方网站携带本网站的cookie信息：设置same-site属性，same-site属性有两个值，Strict（所有的第三方请求都不能携带本网站的cookie）和Lax（链接可以，但是form表单提交和ajax请求不行）
  本网站前端页面添加验证信息：使用验证码或者添加token验证
  验证码：当发起请求时，前端需要输入本网站页面的验证码信息，后端对验证码进行验证，验证码正确才会进行相关操作（存取数据等）<br>

  token验证：a站前端将token存在当前页面中（比如表单中的input隐藏域，meta标签或者任何一个dom的属性）和cookie中，当请求a站后端的时候，参数中带上这个token字段，a站后端将参数中的token和cookie中的token做对比， 相同则验证通过，不同则请求不合法<br>

  不管是验证码还是token验证，原理都是一样的，在a站前端页面加入验证，当第三方网站请求a站后端时，即使能携带a站cookie，但是因为没有经过a站的前端页面从而拿不到验证信息，也会导致请求失败。<br>

  两种防御的方法也有区别，验证码需要用户去填写，从而增加了用户使用网站的复杂度，而token验证在用户无感知的情况下就可以实现，不影响用户体验。我个人理解，验证码验证一般使用在需要提高用户认知的场景，比如，登录多次失败，修改个人信息（用户名，密码，绑定手机号等等），而一些获取商品列表信息，搜索等接口，使用token比较合理。可以看看我们平时使用的这些网站。<br>

  referer验证：禁止来自第三方的请求
  即在一些页面中添加一张图片，图片的src是用作一个可以发请求的url地址，这样每次加载这个页面，都会调用这个API请求，从而达到攻击目的

# sql注入<br>

  攻击方式： 即用户会输入一段sql代码，操作数据库<br>

  解决方式： 过滤用户的特殊输入,nodejs使用mysql里面的escape方法进行输入过滤。<br>